// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package common_mock

import (
	"sync"
)

// IFileWriterMock is a mock implementation of common.IFileWriter.
//
// 	func TestSomethingThatUsesIFileWriter(t *testing.T) {
//
// 		// make and configure a mocked common.IFileWriter
// 		mockedIFileWriter := &IFileWriterMock{
// 			DeleteFileFunc: func(path string) error {
// 				panic("mock out the DeleteFile method")
// 			},
// 			FileExistsFunc: func(path string) bool {
// 				panic("mock out the FileExists method")
// 			},
// 			MakeDirFunc: func(path string) error {
// 				panic("mock out the MakeDir method")
// 			},
// 			WriteBase64EncodedFileFunc: func(path string, content string) error {
// 				panic("mock out the WriteBase64EncodedFile method")
// 			},
// 			WriteFileFunc: func(path string, content []byte) error {
// 				panic("mock out the WriteFile method")
// 			},
// 		}
//
// 		// use mockedIFileWriter in code that requires common.IFileWriter
// 		// and then make assertions.
//
// 	}
type IFileWriterMock struct {
	// DeleteFileFunc mocks the DeleteFile method.
	DeleteFileFunc func(path string) error

	// FileExistsFunc mocks the FileExists method.
	FileExistsFunc func(path string) bool

	// MakeDirFunc mocks the MakeDir method.
	MakeDirFunc func(path string) error

	// WriteBase64EncodedFileFunc mocks the WriteBase64EncodedFile method.
	WriteBase64EncodedFileFunc func(path string, content string) error

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(path string, content []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteFile holds details about calls to the DeleteFile method.
		DeleteFile []struct {
			// Path is the path argument value.
			Path string
		}
		// FileExists holds details about calls to the FileExists method.
		FileExists []struct {
			// Path is the path argument value.
			Path string
		}
		// MakeDir holds details about calls to the MakeDir method.
		MakeDir []struct {
			// Path is the path argument value.
			Path string
		}
		// WriteBase64EncodedFile holds details about calls to the WriteBase64EncodedFile method.
		WriteBase64EncodedFile []struct {
			// Path is the path argument value.
			Path string
			// Content is the content argument value.
			Content string
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Path is the path argument value.
			Path string
			// Content is the content argument value.
			Content []byte
		}
	}
	lockDeleteFile             sync.RWMutex
	lockFileExists             sync.RWMutex
	lockMakeDir                sync.RWMutex
	lockWriteBase64EncodedFile sync.RWMutex
	lockWriteFile              sync.RWMutex
}

// DeleteFile calls DeleteFileFunc.
func (mock *IFileWriterMock) DeleteFile(path string) error {
	if mock.DeleteFileFunc == nil {
		panic("IFileWriterMock.DeleteFileFunc: method is nil but IFileWriter.DeleteFile was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockDeleteFile.Lock()
	mock.calls.DeleteFile = append(mock.calls.DeleteFile, callInfo)
	mock.lockDeleteFile.Unlock()
	return mock.DeleteFileFunc(path)
}

// DeleteFileCalls gets all the calls that were made to DeleteFile.
// Check the length with:
//     len(mockedIFileWriter.DeleteFileCalls())
func (mock *IFileWriterMock) DeleteFileCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockDeleteFile.RLock()
	calls = mock.calls.DeleteFile
	mock.lockDeleteFile.RUnlock()
	return calls
}

// FileExists calls FileExistsFunc.
func (mock *IFileWriterMock) FileExists(path string) bool {
	if mock.FileExistsFunc == nil {
		panic("IFileWriterMock.FileExistsFunc: method is nil but IFileWriter.FileExists was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockFileExists.Lock()
	mock.calls.FileExists = append(mock.calls.FileExists, callInfo)
	mock.lockFileExists.Unlock()
	return mock.FileExistsFunc(path)
}

// FileExistsCalls gets all the calls that were made to FileExists.
// Check the length with:
//     len(mockedIFileWriter.FileExistsCalls())
func (mock *IFileWriterMock) FileExistsCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockFileExists.RLock()
	calls = mock.calls.FileExists
	mock.lockFileExists.RUnlock()
	return calls
}

// MakeDir calls MakeDirFunc.
func (mock *IFileWriterMock) MakeDir(path string) error {
	if mock.MakeDirFunc == nil {
		panic("IFileWriterMock.MakeDirFunc: method is nil but IFileWriter.MakeDir was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockMakeDir.Lock()
	mock.calls.MakeDir = append(mock.calls.MakeDir, callInfo)
	mock.lockMakeDir.Unlock()
	return mock.MakeDirFunc(path)
}

// MakeDirCalls gets all the calls that were made to MakeDir.
// Check the length with:
//     len(mockedIFileWriter.MakeDirCalls())
func (mock *IFileWriterMock) MakeDirCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockMakeDir.RLock()
	calls = mock.calls.MakeDir
	mock.lockMakeDir.RUnlock()
	return calls
}

// WriteBase64EncodedFile calls WriteBase64EncodedFileFunc.
func (mock *IFileWriterMock) WriteBase64EncodedFile(path string, content string) error {
	if mock.WriteBase64EncodedFileFunc == nil {
		panic("IFileWriterMock.WriteBase64EncodedFileFunc: method is nil but IFileWriter.WriteBase64EncodedFile was just called")
	}
	callInfo := struct {
		Path    string
		Content string
	}{
		Path:    path,
		Content: content,
	}
	mock.lockWriteBase64EncodedFile.Lock()
	mock.calls.WriteBase64EncodedFile = append(mock.calls.WriteBase64EncodedFile, callInfo)
	mock.lockWriteBase64EncodedFile.Unlock()
	return mock.WriteBase64EncodedFileFunc(path, content)
}

// WriteBase64EncodedFileCalls gets all the calls that were made to WriteBase64EncodedFile.
// Check the length with:
//     len(mockedIFileWriter.WriteBase64EncodedFileCalls())
func (mock *IFileWriterMock) WriteBase64EncodedFileCalls() []struct {
	Path    string
	Content string
} {
	var calls []struct {
		Path    string
		Content string
	}
	mock.lockWriteBase64EncodedFile.RLock()
	calls = mock.calls.WriteBase64EncodedFile
	mock.lockWriteBase64EncodedFile.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *IFileWriterMock) WriteFile(path string, content []byte) error {
	if mock.WriteFileFunc == nil {
		panic("IFileWriterMock.WriteFileFunc: method is nil but IFileWriter.WriteFile was just called")
	}
	callInfo := struct {
		Path    string
		Content []byte
	}{
		Path:    path,
		Content: content,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(path, content)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//     len(mockedIFileWriter.WriteFileCalls())
func (mock *IFileWriterMock) WriteFileCalls() []struct {
	Path    string
	Content []byte
} {
	var calls []struct {
		Path    string
		Content []byte
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
